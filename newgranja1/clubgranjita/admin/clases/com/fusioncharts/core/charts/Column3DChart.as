class com.fusioncharts.core.charts.Column3DChart extends com.fusioncharts.core.SingleYAxis3DChart
{
    var _version, log, _arrObjects, data, num, config, lang, renderAppMessage, tfAppMsg, detectNumberScales, calcDivs, validateTrendLines, calcTrendLinePos, feedMacros, removeAppMessage, setToolTipParam, drawBackground, drawClickURLHandler, loadBgSWF, params, objects, styleM, timeElapsed, drawCanvas, drawDivLines, drawTrendLines, drawVLines, xmlData, getAttributesArray, getFV, getSetValue, defColors, getFN, numNeg, numPos, parseVLineNode, toBoolean, formatColor, getAxisLimits, numVLines, vLines, formatNumber, width, _embeddedFont, testTFY, testTFX, tfTestMC, createText, elements, returnDataAsElement, divLines, numTrendLines, trendLines, height, getAxisPosition, dm, cMC, macro, printChart, tTip;
    function Column3DChart(targetMC, depth, width, height, x, y, debugMode, lang)
    {
        super(targetMC, depth, width, height, x, y, debugMode, lang);
        this.log("Version", _version, com.fusioncharts.helper.Logger.LEVEL.INFO);
        this.log("Chart Type", "Single Series 3D Column Chart", com.fusioncharts.helper.Logger.LEVEL.INFO);
        _arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "YAXISNAME", "XAXISNAME", "DIVLINES", "YAXISVALUES", "DATALABELS", "DATAVALUES", "TRENDLINES", "TRENDVALUES", "DATAPLOT", "TOOLTIP", "VLINES");
        super.setChartObjects(_arrObjects);
        data = new Array();
        num = 0;
        config.negativePresent = false;
    } // End of the function
    function render()
    {
        this.parseXML();
        if (num == 0)
        {
            tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", lang));
            this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn\'t any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", com.fusioncharts.helper.Logger.LEVEL.ERROR);
        }
        else
        {
            this.detectNumberScales();
            this.calculateAxisLimits();
            this.calcDivs();
            this.setStyleDefaults();
            this.validateTrendLines();
            this.calculatePoints();
            this.calcVLinesPos();
            this.calcTrendLinePos();
            this.allotDepths();
            this.feedMacros();
            this.removeAppMessage(tfAppMsg);
            this.setToolTipParam();
            this.drawBackground();
            this.drawClickURLHandler();
            this.loadBgSWF();
            timeElapsed = params.animation ? (styleM.getMaxAnimationTime(objects.BACKGROUND)) : (0);
            config.intervals.canvas = setInterval(mx.utils.Delegate.create(this, drawCanvas), timeElapsed);
            config.intervals.headers = setInterval(mx.utils.Delegate.create(this, drawHeaders), timeElapsed);
            timeElapsed = timeElapsed + (params.animation ? (styleM.getMaxAnimationTime(objects.CANVAS, objects.CAPTION, objects.SUBCAPTION, objects.YAXISNAME, objects.XAXISNAME)) : (0));
            config.intervals.divLines = setInterval(mx.utils.Delegate.create(this, drawDivLines), timeElapsed);
            timeElapsed = timeElapsed + (params.animation ? (styleM.getMaxAnimationTime(objects.DIVLINES, objects.YAXISVALUES)) : (0));
            config.intervals.labels = setInterval(mx.utils.Delegate.create(this, drawLabels), timeElapsed);
            config.intervals.plot = setInterval(mx.utils.Delegate.create(this, drawColumns), timeElapsed);
            timeElapsed = timeElapsed + (params.animation ? (styleM.getMaxAnimationTime(objects.DATALABELS, objects.DATAPLOT)) : (0));
            config.intervals.dataValues = setInterval(mx.utils.Delegate.create(this, drawValues), timeElapsed);
            config.intervals.trend = setInterval(mx.utils.Delegate.create(this, drawTrendLines), timeElapsed);
            config.intervals.vLine = setInterval(mx.utils.Delegate.create(this, drawVLines), timeElapsed);
            timeElapsed = timeElapsed + (params.animation ? (styleM.getMaxAnimationTime(objects.TRENDLINES, objects.TRENDVALUES, objects.VLINES, objects.DATAVALUES)) : (0));
            this.setContextMenu();
        } // end else if
    } // End of the function
    function returnDataAsObject(label, value, color, alpha, toolText, link, showLabel, showValue)
    {
        var _loc1 = new Object();
        _loc1.label = label;
        _loc1.value = value;
        _loc1.color = color;
        _loc1.alpha = alpha;
        _loc1.toolText = toolText;
        _loc1.link = link;
        _loc1.showLabel = showLabel == 1 && label != "" ? (true) : (false);
        _loc1.showValue = showValue == 1 ? (true) : (false);
        _loc1.isDefined = _loc1.alpha == 0 || isNaN(value) ? (false) : (true);
        _loc1.x = 0;
        _loc1.y = 0;
        _loc1.w = 0;
        _loc1.h = 0;
        _loc1.valTBX = 0;
        _loc1.valTBY = 0;
        return (_loc1);
    } // End of the function
    function parseXML()
    {
        var _loc18 = xmlData.childNodes;
        var _loc7;
        var _loc4;
        for (var _loc7 = 0; _loc7 < _loc18.length; ++_loc7)
        {
            if (_loc18[_loc7].nodeName.toUpperCase() == "GRAPH" || _loc18[_loc7].nodeName.toUpperCase() == "CHART")
            {
                this.parseAttributes(_loc18[_loc7]);
                var _loc5 = _loc18[_loc7].childNodes;
                var _loc19;
                for (var _loc4 = 0; _loc4 < _loc5.length; ++_loc4)
                {
                    if (_loc5[_loc4].nodeName.toUpperCase() == "SET")
                    {
                        ++num;
                        _loc19 = _loc5[_loc4];
                        var _loc3;
                        _loc3 = this.getAttributesArray(_loc19);
                        var _loc11 = this.getFV(_loc3.label, _loc3.name, "");
                        var _loc6 = this.getSetValue(_loc3.value);
                        var _loc13 = this.getFV(_loc3.link, "");
                        var _loc15 = this.getFV(_loc3.tooltext, _loc3.hovertext);
                        var _loc17 = this.getFV(_loc3.color, defColors.getColor());
                        var _loc10 = this.getFN(_loc3.alpha, params.plotFillAlpha);
                        var _loc8 = this.getFN(_loc3.showlabel, _loc3.showname, params.showLabels);
                        var _loc14 = this.getFN(_loc3.showvalue, params.showValues);
                        data[num] = this.returnDataAsObject(_loc11, _loc6, _loc17, _loc10, _loc15, _loc13, _loc8, _loc14);
                        if (_loc6 < 0)
                        {
                            ++numNeg;
                        }
                        else
                        {
                            ++numPos;
                        } // end else if
                        continue;
                    } // end if
                    if (_loc5[_loc4].nodeName.toUpperCase() == "VLINE")
                    {
                        var _loc16 = _loc5[_loc4];
                        this.parseVLineNode(_loc16, num);
                        continue;
                    } // end if
                    if (_loc5[_loc4].nodeName.toUpperCase() == "STYLES")
                    {
                        var _loc12 = _loc5[_loc4].childNodes;
                        super.parseStyleXML(_loc12);
                        continue;
                    } // end if
                    if (_loc5[_loc4].nodeName.toUpperCase() == "TRENDLINES")
                    {
                        var _loc9 = _loc5[_loc4].childNodes;
                        super.parseTrendLineXML(_loc9);
                    } // end if
                } // end of for
            } // end if
        } // end of for
        false;
        false;
        false;
    } // End of the function
    function parseAttributes(graphElement)
    {
        var _loc2 = this.getAttributesArray(graphElement);
        params.palette = this.getFN(_loc2.palette, 1);
        params.showFCMenuItem = this.toBoolean(this.getFN(_loc2.showfcmenuitem, 1));
        params.captionPadding = this.getFN(_loc2.captionpadding, 10);
        params.canvasPadding = this.getFN(_loc2.canvaspadding, 10);
        params.xAxisNamePadding = this.getFN(_loc2.xaxisnamepadding, 5);
        params.yAxisNamePadding = this.getFN(_loc2.yaxisnamepadding, 5);
        params.yAxisValuesPadding = this.getFN(_loc2.yaxisvaluespadding, 2);
        params.labelPadding = this.getFN(_loc2.labelpadding, _loc2.labelspadding, 3);
        params.valuePadding = this.getFN(_loc2.valuepadding, 2);
        params.plotSpacePercent = this.getFN(_loc2.plotspacepercent, 20);
        if (params.plotSpacePercent < 0 || params.plotSpacePercent > 80)
        {
            params.plotSpacePercent = 20;
        } // end if
        params.chartLeftMargin = this.getFN(_loc2.chartleftmargin, 15);
        params.chartRightMargin = this.getFN(_loc2.chartrightmargin, 15);
        params.chartTopMargin = this.getFN(_loc2.charttopmargin, 15);
        params.chartBottomMargin = this.getFN(_loc2.chartbottommargin, 15);
        params.caption = this.getFV(_loc2.caption, "");
        params.subCaption = this.getFV(_loc2.subcaption, "");
        params.xAxisName = this.getFV(_loc2.xaxisname, "");
        params.yAxisName = this.getFV(_loc2.yaxisname, "");
        params.setAdaptiveYMin = this.toBoolean(this.getFN(_loc2.setadaptiveymin, 0));
        params.yAxisMinValue = _loc2.yaxisminvalue;
        params.yAxisMaxValue = _loc2.yaxismaxvalue;
        params.animation = this.toBoolean(this.getFN(_loc2.animation, 1));
        params.defaultAnimation = this.toBoolean(this.getFN(_loc2.defaultanimation, 1));
        params.overlapColumns = _loc2.overlapcolumns;
        params.maxColWidth = this.getFN(_loc2.maxcolwidth, 100);
        params.showLabels = this.toBoolean(this.getFN(_loc2.showlabels, _loc2.shownames, 1));
        params.labelDisplay = this.getFV(_loc2.labeldisplay, "WRAP");
        params.labelDisplay = com.fusioncharts.extensions.StringExt.removeSpaces(params.labelDisplay);
        params.labelDisplay = params.labelDisplay.toUpperCase();
        params.rotateLabels = this.getFV(_loc2.rotatelabels, _loc2.rotatenames);
        params.slantLabels = this.toBoolean(this.getFN(_loc2.slantlabels, _loc2.slantlabel, 0));
        config.labelAngle = params.slantLabels == true ? (315) : (270);
        params.labelDisplay = params.rotateLabels == "1" ? ("ROTATE") : (params.labelDisplay);
        params.labelStep = int(this.getFN(_loc2.labelstep, 1));
        params.labelStep = params.labelStep < 1 ? (1) : (params.labelStep);
        params.staggerLines = int(this.getFN(_loc2.staggerlines, 2));
        params.staggerLines = params.staggerLines < 2 ? (2) : (params.staggerLines);
        params.showValues = this.toBoolean(this.getFN(_loc2.showvalues, 1));
        params.rotateValues = this.toBoolean(this.getFN(_loc2.rotatevalues, 0));
        params.placeValuesInside = this.toBoolean(this.getFN(_loc2.placevaluesinside, 0));
        params.showYAxisValues = this.getFN(_loc2.showyaxisvalues, _loc2.showyaxisvalue, 1);
        params.showLimits = this.toBoolean(this.getFN(_loc2.showlimits, params.showYAxisValues));
        params.showDivLineValues = this.toBoolean(this.getFN(_loc2.showdivlinevalue, _loc2.showdivlinevalues, params.showYAxisValues));
        params.yAxisValuesStep = int(this.getFN(_loc2.yaxisvaluesstep, _loc2.yaxisvaluestep, 1));
        params.yAxisValuesStep = params.yAxisValuesStep < 1 ? (1) : (params.yAxisValuesStep);
        params.adjustDiv = this.toBoolean(this.getFN(_loc2.adjustdiv, 1));
        params.rotateYAxisName = this.toBoolean(this.getFN(_loc2.rotateyaxisname, 1));
        params.yAxisNameWidth = _loc2.yaxisnamewidth;
        params.columnDepth = this.getFN(_loc2.columndepth, -1);
        params.clickURL = this.getFV(_loc2.clickurl, "");
        params.use3DLighting = this.toBoolean(this.getFN(_loc2.use3dlighting, 1));
        params.showColumnShadow = this.toBoolean(this.getFN(_loc2.showshadow, _loc2.showcolumnshadow, params.use3DLighting));
        params.bgColor = this.getFV(_loc2.bgcolor, defColors.getBgColor3D(params.palette));
        params.bgAlpha = this.getFV(_loc2.bgalpha, defColors.getBgAlpha3D(params.palette));
        params.bgRatio = this.getFV(_loc2.bgratio, defColors.getBgRatio3D(params.palette));
        params.bgAngle = this.getFV(_loc2.bgangle, defColors.getBgAngle3D(params.palette));
        params.showBorder = this.toBoolean(this.getFN(_loc2.showborder, 0));
        params.borderColor = this.formatColor(this.getFV(_loc2.bordercolor, "666666"));
        params.borderThickness = this.getFN(_loc2.borderthickness, 1);
        params.borderAlpha = this.getFN(_loc2.borderalpha, 100);
        params.bgSWF = this.getFV(_loc2.bgswf, "");
        params.bgSWFAlpha = this.getFN(_loc2.bgswfalpha, 100);
        params.canvasBgColor = this.formatColor(this.getFV(_loc2.canvasbgcolor, defColors.getCanvasBgColor3D(params.palette)));
        params.canvasBgAlpha = this.getFN(_loc2.canvasbgalpha, 100);
        params.canvasBaseColor = this.formatColor(this.getFV(_loc2.canvasbasecolor, defColors.getCanvasBaseColor3D(params.palette)));
        params.showCanvasBg = this.toBoolean(this.getFN(_loc2.showcanvasbg, 1));
        params.showCanvasBase = this.toBoolean(this.getFN(_loc2.showcanvasbase, 1));
        params.canvasBaseDepth = this.getFN(_loc2.canvasbasedepth, 10);
        params.canvasBgDepth = this.getFN(_loc2.canvasbgdepth, 3);
        params.showPlotBorder = this.toBoolean(this.getFN(_loc2.showplotborder, 0));
        params.plotBorderColor = this.formatColor(this.getFV(_loc2.plotbordercolor, "333333"));
        params.plotBorderAlpha = this.getFN(_loc2.plotborderalpha, params.showPlotBorder == true ? (95) : (0));
        params.plotFillAlpha = this.getFV(_loc2.plotfillalpha, "100");
        params.numDivLines = this.getFN(_loc2.numdivlines, 4);
        params.divLineColor = this.formatColor(this.getFV(_loc2.divlinecolor, defColors.getDivLineColor3D(params.palette)));
        params.divLineThickness = this.getFN(_loc2.divlinethickness, 1);
        params.divLineAlpha = this.getFN(_loc2.divlinealpha, 100);
        params.divLineIsDashed = this.toBoolean(this.getFN(_loc2.divlineisdashed, 0));
        params.divLineDashLen = this.getFN(_loc2.divlinedashlen, 4);
        params.divLineDashGap = this.getFN(_loc2.divlinedashgap, 2);
        params.showZeroPlane = true;
        params.zeroPlaneColor = this.formatColor(this.getFV(_loc2.zeroplanecolor, params.divLineColor));
        params.zeroPlaneAlpha = this.getFN(_loc2.zeroplanealpha, 75);
        params.zeroPlaneShowBorder = this.toBoolean(this.getFN(_loc2.zeroplaneshowborder, 1));
        params.zeroPlaneBorderColor = this.formatColor(this.getFV(_loc2.zeroplanebordercolor, params.zeroPlaneColor));
        params.showToolTip = this.toBoolean(this.getFN(_loc2.showtooltip, _loc2.showhovercap, 1));
        params.toolTipBgColor = this.formatColor(this.getFV(_loc2.tooltipbgcolor, _loc2.hovercapbgcolor, _loc2.hovercapbg, defColors.getToolTipBgColor3D(params.palette)));
        params.toolTipBorderColor = this.formatColor(this.getFV(_loc2.tooltipbordercolor, _loc2.hovercapbordercolor, _loc2.hovercapborder, defColors.getToolTipBorderColor3D(params.palette)));
        params.toolTipSepChar = this.getFV(_loc2.tooltipsepchar, _loc2.hovercapsepchar, ", ");
        params.baseFont = this.getFV(_loc2.basefont, "Verdana");
        params.baseFontSize = this.getFN(_loc2.basefontsize, 10);
        params.baseFontColor = this.formatColor(this.getFV(_loc2.basefontcolor, defColors.getBaseFontColor3D(params.palette)));
        params.outCnvBaseFont = this.getFV(_loc2.outcnvbasefont, params.baseFont);
        params.outCnvBaseFontSize = this.getFN(_loc2.outcnvbasefontsize, params.baseFontSize);
        params.outCnvBaseFontColor = this.formatColor(this.getFV(_loc2.outcnvbasefontcolor, params.baseFontColor));
        params.formatNumber = this.toBoolean(this.getFN(_loc2.formatnumber, 1));
        params.formatNumberScale = this.toBoolean(this.getFN(_loc2.formatnumberscale, 1));
        params.defaultNumberScale = this.getFV(_loc2.defaultnumberscale, "");
        params.numberScaleUnit = this.getFV(_loc2.numberscaleunit, "K,M");
        params.numberScaleValue = this.getFV(_loc2.numberscalevalue, "1000,1000");
        params.numberPrefix = this.getFV(_loc2.numberprefix, "");
        params.numberSuffix = this.getFV(_loc2.numbersuffix, "");
        params.decimalSeparator = this.getFV(_loc2.decimalseparator, ".");
        params.thousandSeparator = this.getFV(_loc2.thousandseparator, ",");
        params.inDecimalSeparator = this.getFV(_loc2.indecimalseparator, "");
        params.inThousandSeparator = this.getFV(_loc2.inthousandseparator, "");
        params.decimals = this.getFV(_loc2.decimals, _loc2.decimalprecision);
        params.forceDecimals = this.toBoolean(this.getFN(_loc2.forcedecimals, 0));
        params.yAxisValueDecimals = this.getFV(_loc2.yaxisvaluedecimals, _loc2.yaxisvaluesdecimals, _loc2.divlinedecimalprecision, _loc2.limitsdecimalprecision);
    } // End of the function
    function getMaxDataValue()
    {
        var _loc3;
        var _loc4 = false;
        var _loc2;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            if (_loc4 == false)
            {
                if (data[_loc2].isDefined == true)
                {
                    _loc4 = true;
                    _loc3 = data[_loc2].value;
                } // end if
                continue;
            } // end if
            if (data[_loc2].isDefined)
            {
                _loc3 = data[_loc2].value > _loc3 ? (data[_loc2].value) : (_loc3);
            } // end if
        } // end of for
        return (_loc3);
    } // End of the function
    function getMinDataValue()
    {
        var _loc3;
        var _loc4 = false;
        var _loc2;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            if (_loc4 == false)
            {
                if (data[_loc2].isDefined == true)
                {
                    _loc4 = true;
                    _loc3 = data[_loc2].value;
                } // end if
                continue;
            } // end if
            if (data[_loc2].isDefined)
            {
                _loc3 = data[_loc2].value < _loc3 ? (data[_loc2].value) : (_loc3);
            } // end if
        } // end of for
        return (_loc3);
    } // End of the function
    function calculateAxisLimits()
    {
        this.getAxisLimits(this.getMaxDataValue(), this.getMinDataValue(), true, !params.setAdaptiveYMin);
    } // End of the function
    function setStyleDefaults()
    {
        var _loc6 = new com.fusioncharts.core.StyleObject();
        _loc6.name = "_SdCaptionFont";
        _loc6.align = "center";
        _loc6.valign = "top";
        _loc6.bold = "1";
        _loc6.font = params.outCnvBaseFont;
        _loc6.size = params.outCnvBaseFontSize;
        _loc6.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.CAPTION, _loc6, styleM.TYPE.FONT, null);
        false;
        var _loc2 = new com.fusioncharts.core.StyleObject();
        _loc2.name = "_SdSubCaptionFont";
        _loc2.align = "center";
        _loc2.valign = "top";
        _loc2.bold = "1";
        _loc2.font = params.outCnvBaseFont;
        _loc2.size = params.outCnvBaseFontSize;
        _loc2.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.SUBCAPTION, _loc2, styleM.TYPE.FONT, null);
        false;
        var _loc3 = new com.fusioncharts.core.StyleObject();
        _loc3.name = "_SdYAxisNameFont";
        _loc3.align = "center";
        _loc3.valign = "middle";
        _loc3.bold = "1";
        _loc3.font = params.outCnvBaseFont;
        _loc3.size = params.outCnvBaseFontSize;
        _loc3.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.YAXISNAME, _loc3, styleM.TYPE.FONT, null);
        false;
        var _loc5 = new com.fusioncharts.core.StyleObject();
        _loc5.name = "_SdXAxisNameFont";
        _loc5.align = "center";
        _loc5.valign = "middle";
        _loc5.bold = "1";
        _loc5.font = params.outCnvBaseFont;
        _loc5.size = params.outCnvBaseFontSize;
        _loc5.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.XAXISNAME, _loc5, styleM.TYPE.FONT, null);
        false;
        var _loc12 = new com.fusioncharts.core.StyleObject();
        _loc12.name = "_SdTrendFont";
        _loc12.font = params.outCnvBaseFont;
        _loc12.size = params.outCnvBaseFontSize;
        _loc12.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.TRENDVALUES, _loc12, styleM.TYPE.FONT, null);
        false;
        var _loc7 = new com.fusioncharts.core.StyleObject();
        _loc7.name = "_SdYAxisValuesFont";
        _loc7.align = "right";
        _loc7.valign = "middle";
        _loc7.font = params.outCnvBaseFont;
        _loc7.size = params.outCnvBaseFontSize;
        _loc7.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.YAXISVALUES, _loc7, styleM.TYPE.FONT, null);
        false;
        var _loc10 = new com.fusioncharts.core.StyleObject();
        _loc10.name = "_SdDataLabelsFont";
        _loc10.align = "center";
        _loc10.valign = "bottom";
        _loc10.font = params.outCnvBaseFont;
        _loc10.size = params.outCnvBaseFontSize;
        _loc10.color = params.outCnvBaseFontColor;
        styleM.overrideStyle(objects.DATALABELS, _loc10, styleM.TYPE.FONT, null);
        false;
        var _loc11 = new com.fusioncharts.core.StyleObject();
        _loc11.name = "_SdDataValuesFont";
        _loc11.align = "center";
        _loc11.valign = "middle";
        _loc11.font = params.baseFont;
        _loc11.size = params.baseFontSize;
        _loc11.color = params.baseFontColor;
        styleM.overrideStyle(objects.DATAVALUES, _loc11, styleM.TYPE.FONT, null);
        false;
        var _loc8 = new com.fusioncharts.core.StyleObject();
        _loc8.name = "_SdToolTipFont";
        _loc8.font = params.baseFont;
        _loc8.size = params.baseFontSize;
        _loc8.color = params.baseFontColor;
        _loc8.bgcolor = params.toolTipBgColor;
        _loc8.bordercolor = params.toolTipBorderColor;
        styleM.overrideStyle(objects.TOOLTIP, _loc8, styleM.TYPE.FONT, null);
        false;
        if (params.showColumnShadow)
        {
            var _loc4 = new com.fusioncharts.core.StyleObject();
            _loc4.name = "_SdDataPlotShadow";
            _loc4.distance = 3;
            _loc4.angle = 315;
            _loc4.alpha = 75;
            _loc4.color = "666666";
            _loc4.blurx = 8;
            _loc4.blury = 8;
            styleM.overrideStyle(objects.DATAPLOT, _loc4, styleM.TYPE.SHADOW, null);
            false;
        } // end if
        if (params.defaultAnimation)
        {
            var _loc9 = new com.fusioncharts.core.StyleObject();
            _loc9.name = "_SdDataPlotAnim";
            _loc9.param = "_yscale";
            _loc9.easing = "regular";
            _loc9.wait = 0;
            _loc9.start = 0;
            _loc9.duration = 1;
            styleM.overrideStyle(objects.DATAPLOT, _loc9, styleM.TYPE.ANIMATION, "_yscale");
            false;
        } // end if
    } // End of the function
    function calcVLinesPos()
    {
        var _loc2;
        for (var _loc2 = 1; _loc2 <= numVLines; ++_loc2)
        {
            if (vLines[_loc2].index > 0 && vLines[_loc2].index < num)
            {
                vLines[_loc2].x = data[vLines[_loc2].index].x + (data[vLines[_loc2].index + 1].x - data[vLines[_loc2].index].x) / 2;
                continue;
            } // end if
            vLines[_loc2].isValid = false;
        } // end of for
    } // End of the function
    function calculatePoints()
    {
        var _loc2;
        var _loc9;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            data[_loc2].displayValue = this.formatNumber(data[_loc2].value, params.formatNumber, params.decimals, params.forceDecimals, params.formatNumberScale, params.defaultNumberScale, config.nsv, config.nsu, params.numberPrefix, params.numberSuffix);
            _loc9 = data[_loc2].label != "" ? (data[_loc2].label + params.toolTipSepChar) : ("");
            _loc9 = _loc9 + data[_loc2].displayValue;
            data[_loc2].toolText = this.getFV(data[_loc2].toolText, _loc9);
        } // end of for
        var _loc23 = 0;
        var _loc11 = 0;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            if (data[_loc2].showLabel)
            {
                ++_loc23;
                if ((_loc2 - 1) % params.labelStep == 0)
                {
                    data[_loc2].showLabel = true;
                }
                else
                {
                    data[_loc2].showLabel = false;
                } // end if
            } // end else if
            _loc11 = data[_loc2].showLabel ? (_loc11 + 1) : (_loc11);
        } // end of for
        var _loc15 = width - (params.chartLeftMargin + params.chartRightMargin);
        var _loc19 = params.chartLeftMargin;
        if (params.yAxisName != "")
        {
            var _loc24 = styleM.getTextStyle(objects.YAXISNAME);
            if (params.rotateYAxisName)
            {
                _loc24.font = _embeddedFont;
                _loc24.bold = false;
                _loc24.italic = false;
                var _loc28 = this.createText(true, params.yAxisName, tfTestMC, 1, testTFX, testTFY, 90, _loc24, false, 0, 0);
                _loc19 = _loc19 + _loc28.width + params.yAxisNamePadding;
                _loc15 = _loc15 - _loc28.width - params.yAxisNamePadding;
                elements.yAxisName = this.returnDataAsElement(0, 0, _loc28.width, _loc28.height);
            }
            else
            {
                _loc28 = this.createText(true, params.yAxisName, tfTestMC, 1, testTFX, testTFY, 0, _loc24, false, 0, 0);
                params.yAxisNameWidth = Number(this.getFV(params.yAxisNameWidth, _loc28.width));
                params.yAxisNameWidth = Math.min(params.yAxisNameWidth, _loc28.width);
                _loc19 = _loc19 + params.yAxisNameWidth + params.yAxisNamePadding;
                _loc15 = _loc15 - params.yAxisNameWidth - params.yAxisNamePadding;
                elements.yAxisName = this.returnDataAsElement(0, 0, params.yAxisNameWidth, _loc28.height);
            } // end else if
            false;
            false;
        } // end if
        var _loc3 = 0;
        var _loc6;
        var _loc18 = styleM.getTextStyle(objects.YAXISVALUES);
        for (var _loc2 = 1; _loc2 < divLines.length; ++_loc2)
        {
            if (divLines[_loc2].showValue)
            {
                if (_loc2 == 1 || _loc2 == divLines.length - 1)
                {
                    if (params.showLimits)
                    {
                        _loc6 = this.createText(true, divLines[_loc2].displayValue, tfTestMC, 1, testTFX, testTFY, 0, _loc18, false, 0, 0);
                        _loc3 = _loc6.width > _loc3 ? (_loc6.width) : (_loc3);
                    } // end if
                    continue;
                } // end if
                if (params.showDivLineValues)
                {
                    _loc6 = this.createText(true, divLines[_loc2].displayValue, tfTestMC, 1, testTFX, testTFY, 0, _loc18, false, 0, 0);
                    _loc3 = _loc6.width > _loc3 ? (_loc6.width) : (_loc3);
                } // end if
            } // end if
        } // end of for
        false;
        var _loc17 = styleM.getTextStyle(objects.TRENDVALUES);
        var _loc7;
        for (var _loc2 = 1; _loc2 <= numTrendLines; ++_loc2)
        {
            if (trendLines[_loc2].isValid == true && trendLines[_loc2].valueOnRight == false)
            {
                _loc7 = this.createText(true, trendLines[_loc2].displayValue, tfTestMC, 1, testTFX, testTFY, 0, _loc17, false, 0, 0);
                _loc3 = _loc7.width > _loc3 ? (_loc7.width) : (_loc3);
            } // end if
        } // end of for
        if (_loc3 > 0)
        {
            _loc19 = _loc19 + _loc3 + params.yAxisValuesPadding;
            _loc15 = _loc15 - _loc3 - params.yAxisValuesPadding;
        } // end if
        var _loc10 = 0;
        for (var _loc2 = 1; _loc2 <= numTrendLines; ++_loc2)
        {
            if (trendLines[_loc2].isValid == true && trendLines[_loc2].valueOnRight == true)
            {
                _loc7 = this.createText(true, trendLines[_loc2].displayValue, tfTestMC, 1, testTFX, testTFY, 0, _loc17, false, 0, 0);
                _loc10 = _loc7.width > _loc10 ? (_loc7.width) : (_loc10);
            } // end if
        } // end of for
        false;
        if (_loc10 > 0)
        {
            _loc15 = _loc15 - _loc10 - params.yAxisValuesPadding;
        } // end if
        _loc19 = int(_loc19);
        _loc15 = int(_loc15);
        var _loc16 = height - (params.chartTopMargin + params.chartBottomMargin);
        var _loc20 = params.chartTopMargin;
        if (params.caption != "")
        {
            var _loc26 = this.createText(true, params.caption, tfTestMC, 1, testTFX, testTFY, 0, styleM.getTextStyle(objects.CAPTION), false, 0, 0);
            _loc20 = _loc20 + _loc26.height;
            _loc16 = _loc16 - _loc26.height;
            elements.caption = this.returnDataAsElement(0, 0, _loc26.width, _loc26.height);
            false;
        } // end if
        if (params.subCaption != "")
        {
            var _loc27 = this.createText(true, params.subCaption, tfTestMC, 1, testTFX, testTFY, 0, styleM.getTextStyle(objects.SUBCAPTION), false, 0, 0);
            _loc20 = _loc20 + _loc27.height;
            _loc16 = _loc16 - _loc27.height;
            elements.subCaption = this.returnDataAsElement(0, 0, _loc27.width, _loc27.height);
            false;
        } // end if
        if (params.caption != "" || params.subCaption != "")
        {
            _loc20 = _loc20 + params.captionPadding;
            _loc16 = _loc16 - params.captionPadding;
        } // end if
        config.maxLabelHeight = 0;
        config.labelAreaHeight = 0;
        var _loc4;
        var _loc5 = styleM.getTextStyle(objects.DATALABELS);
        if (params.labelDisplay == "ROTATE")
        {
            for (var _loc2 = 1; _loc2 <= num; ++_loc2)
            {
                if (data[_loc2].showLabel)
                {
                    _loc5.font = _embeddedFont;
                    _loc5.bold = false;
                    _loc5.italic = false;
                    _loc4 = this.createText(true, data[_loc2].label, tfTestMC, 1, testTFX, testTFY, config.labelAngle, _loc5, false, 0, 0);
                    config.maxLabelHeight = _loc4.height > config.maxLabelHeight ? (_loc4.height) : (config.maxLabelHeight);
                } // end if
            } // end of for
            config.labelAreaHeight = config.maxLabelHeight;
        }
        else if (params.labelDisplay == "WRAP")
        {
            var _loc21 = (_loc15 - 2 * params.canvasPadding) / _loc11;
            var _loc22 = _loc16 / 2;
            config.wrapLabelWidth = _loc21;
            config.wrapLabelHeight = _loc22;
            for (var _loc2 = 1; _loc2 <= num; ++_loc2)
            {
                if (data[_loc2].showLabel)
                {
                    _loc4 = this.createText(true, data[_loc2].label, tfTestMC, 1, testTFX, testTFY, 0, _loc5, true, _loc21, _loc22);
                    config.maxLabelHeight = _loc4.height > config.maxLabelHeight ? (_loc4.height) : (config.maxLabelHeight);
                } // end if
            } // end of for
            config.labelAreaHeight = config.maxLabelHeight;
        }
        else
        {
            var _loc14 = new Array();
            _loc14.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=/*-+~`");
            for (var _loc2 = 1; _loc2 <= num; ++_loc2)
            {
                if (data[_loc2].showLabel)
                {
                    if (data[_loc2].label.indexOf("&lt;") > -1 || data[_loc2].label.indexOf("<") > -1)
                    {
                        _loc14.push(data[_loc2].label);
                    } // end if
                } // end if
            } // end of for
            for (var _loc2 = 0; _loc2 < _loc14.length; ++_loc2)
            {
                _loc4 = this.createText(true, data[_loc2].label, tfTestMC, 1, testTFX, testTFY, 0, _loc5, false, 0, 0);
                config.maxLabelHeight = _loc4.height > config.maxLabelHeight ? (_loc4.height) : (config.maxLabelHeight);
            } // end of for
            if (params.labelDisplay == "STAGGER")
            {
                config.labelAreaHeight = params.staggerLines * config.maxLabelHeight;
            }
            else
            {
                config.labelAreaHeight = config.maxLabelHeight;
            } // end else if
        } // end else if
        if (config.labelAreaHeight > 0)
        {
            _loc16 = _loc16 - config.labelAreaHeight - params.labelPadding;
        } // end if
        false;
        false;
        if (params.xAxisName != "")
        {
            var _loc29 = this.createText(true, params.xAxisName, tfTestMC, 1, testTFX, testTFY, 0, styleM.getTextStyle(objects.XAXISNAME), false, 0, 0);
            _loc16 = _loc16 - _loc29.height - params.xAxisNamePadding;
            elements.xAxisName = this.returnDataAsElement(0, 0, _loc29.width, _loc29.height);
            false;
        } // end if
        elements.canvas = this.returnDataAsElement(_loc19, _loc20, _loc15, _loc16);
        var _loc8 = (elements.canvas.w - params.canvasBgDepth - 2 * params.canvasPadding) * ((100 - params.plotSpacePercent) / 100) / num;
        var _loc30 = _loc8 < params.maxColWidth ? (1) : (0);
        params.overlapColumns = this.toBoolean(this.getFN(params.overlapColumns, _loc30));
        if (!params.overlapColumns || num == 1)
        {
            _loc8 = _loc8 > params.maxColWidth ? (params.maxColWidth) : (_loc8);
        } // end if
        config.shifts = com.fusioncharts.core.chartobjects.Column3D.calcShifts(_loc8, 45, -1);
        if (params.overlapColumns && num > 1)
        {
            params.plotSpacePercent = 0;
            var _loc25 = config.shifts.wShadow * num;
            if (config.shifts.wShadow >= config.shifts.wFront)
            {
                _loc25 = _loc25 * (config.shifts.wFront / config.shifts.wShadow);
            }
            else
            {
                _loc25 = _loc25 * 5.000000E-001;
            } // end else if
            _loc8 = (elements.canvas.w - params.canvasBgDepth + _loc25 * 5.000000E-001 - 2 * params.canvasPadding) / num;
            config.shifts = com.fusioncharts.core.chartobjects.Column3D.calcShifts(_loc8, 45, -1);
        } // end if
        elements.canvasBg = this.returnDataAsElement(elements.canvas.x, elements.canvas.y, elements.canvas.w - params.canvasBgDepth, elements.canvas.h - params.canvasBaseDepth - config.shifts.yShift);
        elements.canvasBase = this.returnDataAsElement(elements.canvas.x, elements.canvasBg.toY, elements.canvasBg.w, config.shifts.yShift);
        if (num > 2)
        {
            var _loc13 = (elements.canvasBg.w - 2 * params.canvasPadding - _loc8 * num) / (num - 1);
        }
        else
        {
            _loc13 = (elements.canvasBg.w - 2 * params.canvasPadding - _loc8 * num) / (num + 1);
        } // end else if
        config.columnWidth = _loc8;
        config.columnSpace = _loc13;
        if (config.yMax >= 0 && config.yMin < 0)
        {
            config.basePlanePos = this.getAxisPosition(0, config.yMax, config.yMin, elements.canvasBg.y, elements.canvasBg.toY, true, 0);
        }
        else
        {
            config.basePlanePos = this.getAxisPosition(config.yMin, config.yMax, config.yMin, elements.canvasBg.y, elements.canvasBg.toY, true, 0);
        } // end else if
        var _loc12;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            if (num > 2)
            {
                data[_loc2].x = elements.canvasBg.x + params.canvasPadding + _loc13 * (_loc2 - 1) + (_loc2 - 5.000000E-001) * _loc8 - config.shifts.xShift;
            }
            else
            {
                data[_loc2].x = elements.canvasBg.x + params.canvasPadding + _loc13 * _loc2 + (_loc2 - 5.000000E-001) * _loc8 - config.shifts.xShift;
            } // end else if
            data[_loc2].y = config.basePlanePos + config.shifts.yShift;
            _loc12 = this.getAxisPosition(data[_loc2].value, config.yMax, config.yMin, elements.canvasBg.y, elements.canvasBg.toY, true, 0);
            data[_loc2].h = -(_loc12 - config.basePlanePos);
            data[_loc2].w = _loc8;
            data[_loc2].valTBY = _loc12;
        } // end of for
    } // End of the function
    function allotDepths()
    {
        dm.reserveDepths("BACKGROUND", 1);
        dm.reserveDepths("CLICKURLHANDLER", 1);
        dm.reserveDepths("BGSWF", 1);
        dm.reserveDepths("CANVASBG", 1);
        dm.reserveDepths("CANVASBASE", 1);
        dm.reserveDepths("DIVLINES", divLines.length * 2);
        dm.reserveDepths("CAPTION", 1);
        dm.reserveDepths("SUBCAPTION", 1);
        dm.reserveDepths("XAXISNAME", 1);
        dm.reserveDepths("YAXISNAME", 1);
        dm.reserveDepths("TRENDLINES", numTrendLines);
        dm.reserveDepths("TRENDVALUES", numTrendLines);
        dm.reserveDepths("VLINES", numVLines);
        dm.reserveDepths("DATALABELS", num);
        dm.reserveDepths("DATAPLOTNEG", numNeg);
        dm.reserveDepths("ZEROPLANE", 2);
        dm.reserveDepths("DATAPLOTPOS", numPos);
        dm.reserveDepths("DATAVALUES", num);
    } // End of the function
    function drawHeaders()
    {
        if (params.caption != "")
        {
            var _loc3 = styleM.getTextStyle(objects.CAPTION);
            _loc3.align = "center";
            _loc3.vAlign = "bottom";
            var _loc8 = this.createText(false, params.caption, cMC, dm.getDepth("CAPTION"), elements.canvasBg.x + elements.canvasBg.w / 2, params.chartTopMargin, 0, _loc3, false, 0, 0);
            if (params.animation)
            {
                styleM.applyAnimation(_loc8.tf, objects.CAPTION, macro, elements.canvasBg.x + elements.canvasBg.w / 2 - elements.caption.w / 2, 0, params.chartTopMargin, 0, 100, null, null, null);
            } // end if
            styleM.applyFilters(_loc8.tf, objects.CAPTION);
            false;
            false;
        } // end if
        if (params.subCaption != "")
        {
            var _loc5 = styleM.getTextStyle(objects.SUBCAPTION);
            _loc5.align = "center";
            _loc5.vAlign = "top";
            var _loc9 = this.createText(false, params.subCaption, cMC, dm.getDepth("SUBCAPTION"), elements.canvasBg.x + elements.canvasBg.w / 2, elements.canvasBg.y - params.captionPadding, 0, _loc5, false, 0, 0);
            if (params.animation)
            {
                styleM.applyAnimation(_loc9.tf, objects.SUBCAPTION, macro, elements.canvasBg.x + elements.canvasBg.w / 2 - elements.subCaption.w / 2, 0, elements.canvasBg.y - params.captionPadding - elements.subCaption.h, 0, 100, null, null, null);
            } // end if
            styleM.applyFilters(_loc9.tf, objects.SUBCAPTION);
            false;
            false;
        } // end if
        if (params.xAxisName != "")
        {
            var _loc6 = styleM.getTextStyle(objects.XAXISNAME);
            _loc6.align = "center";
            _loc6.vAlign = "bottom";
            var _loc7 = this.createText(false, params.xAxisName, cMC, dm.getDepth("XAXISNAME"), elements.canvasBase.x + elements.canvasBase.w / 2, elements.canvas.toY + params.labelPadding + config.labelAreaHeight + params.xAxisNamePadding, 0, _loc6, false, 0, 0);
            if (params.animation)
            {
                styleM.applyAnimation(_loc7.tf, objects.XAXISNAME, macro, elements.canvasBase.x + elements.canvasBase.w / 2 - elements.subCaption.w / 2, 0, elements.canvas.toY + config.labelAreaHeight + params.xAxisNamePadding, 0, 100, null, null, null);
            } // end if
            styleM.applyFilters(_loc7.tf, objects.XAXISNAME);
            false;
            false;
        } // end if
        if (params.yAxisName != "")
        {
            var _loc2 = styleM.getTextStyle(objects.YAXISNAME);
            _loc2.align = "left";
            _loc2.vAlign = "middle";
            if (params.rotateYAxisName)
            {
                _loc2.font = _embeddedFont;
                _loc2.bold = false;
                _loc2.italic = false;
                var _loc4 = this.createText(false, params.yAxisName, cMC, dm.getDepth("YAXISNAME"), params.chartLeftMargin, elements.canvas.y + elements.canvas.h / 2, 270, _loc2, false, 0, 0);
                if (params.animation)
                {
                    styleM.applyAnimation(_loc4.tf, objects.YAXISNAME, macro, params.chartLeftMargin, 0, elements.canvas.y + elements.canvas.h / 2 + elements.yAxisName.h / 2, 0, 100, null, null, null);
                } // end if
            }
            else
            {
                _loc4 = this.createText(false, params.yAxisName, cMC, dm.getDepth("YAXISNAME"), params.chartLeftMargin, elements.canvas.y + elements.canvas.h / 2, 0, _loc2, true, params.yAxisNameWidth + 1, elements.canvas.h);
                if (params.animation)
                {
                    styleM.applyAnimation(_loc4.tf, objects.YAXISNAME, macro, params.chartLeftMargin, 0, _loc4.tf._y, 0, 100, null, null, null);
                } // end if
            } // end else if
            styleM.applyFilters(_loc4.tf, objects.YAXISNAME);
            false;
            false;
        } // end if
        clearInterval(config.intervals.headers);
    } // End of the function
    function drawLabels()
    {
        var _loc5;
        var _loc2 = styleM.getTextStyle(objects.DATALABELS);
        var _loc7;
        var _loc9 = 0;
        var _loc8 = 1;
        var _loc6 = dm.getDepth("DATALABELS");
        var _loc3;
        for (var _loc3 = 1; _loc3 <= num; ++_loc3)
        {
            if (data[_loc3].showLabel)
            {
                if (params.labelDisplay == "ROTATE")
                {
                    _loc2.font = _embeddedFont;
                    _loc2.bold = false;
                    _loc2.italic = false;
                    _loc2.align = "center";
                    _loc2.vAlign = "bottom";
                    _loc5 = this.createText(false, data[_loc3].label, cMC, _loc6, data[_loc3].x, elements.canvas.toY + params.labelPadding, config.labelAngle, _loc2, false, 0, 0);
                }
                else if (params.labelDisplay == "WRAP")
                {
                    _loc2.align = "center";
                    _loc2.vAlign = "bottom";
                    _loc5 = this.createText(false, data[_loc3].label, cMC, _loc6, data[_loc3].x, elements.canvas.toY + params.labelPadding, 0, _loc2, true, config.wrapLabelWidth, config.wrapLabelHeight);
                }
                else if (params.labelDisplay == "STAGGER")
                {
                    _loc2.align = "center";
                    _loc2.vAlign = "bottom";
                    var _loc4 = _loc3 % (2 * params.staggerLines - 2);
                    _loc4 = _loc4 == 0 ? (2 * params.staggerLines - 2) : (_loc4);
                    _loc4 = _loc4 > params.staggerLines ? (params.staggerLines - _loc4 % params.staggerLines) : (_loc4);
                    --_loc4;
                    _loc7 = config.maxLabelHeight * _loc4;
                    _loc5 = this.createText(false, data[_loc3].label, cMC, _loc6, data[_loc3].x, elements.canvas.toY + params.labelPadding + _loc7, 0, _loc2, false, 0, 0);
                }
                else
                {
                    _loc2.align = "center";
                    _loc2.vAlign = "bottom";
                    _loc5 = this.createText(false, data[_loc3].label, cMC, _loc6, data[_loc3].x, elements.canvas.toY + params.labelPadding, 0, _loc2, false, 0, 0);
                } // end else if
                styleM.applyFilters(_loc5.tf, objects.DATALABELS);
                if (params.animation)
                {
                    styleM.applyAnimation(_loc5.tf, objects.DATALABELS, macro, _loc5.tf._x, 0, _loc5.tf._y, 0, 100, null, null, null);
                } // end if
                ++_loc6;
            } // end if
        } // end of for
        clearInterval(config.intervals.labels);
    } // End of the function
    function drawColumns()
    {
        var _loc3;
        var _loc10;
        var _loc8 = dm.getDepth("DATAPLOTPOS");
        var _loc9 = dm.getDepth("DATAPLOTNEG");
        var _loc6;
        var _loc2;
        var _loc5;
        var _loc4;
        var _loc7;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            if (data[_loc2].isDefined)
            {
                if (data[_loc2].value < 0)
                {
                    _loc6 = _loc9;
                    ++_loc9;
                }
                else
                {
                    _loc6 = _loc8;
                    ++_loc8;
                } // end else if
                _loc3 = cMC.createEmptyMovieClip("Column_" + _loc2, _loc6);
                _loc10 = new com.fusioncharts.core.chartobjects.Column3D(_loc3, data[_loc2].x, data[_loc2].y, config.shifts.wFront, data[_loc2].h, config.shifts.xShift, config.shifts.yShift, data[_loc2].color, params.showPlotBorder, params.plotBorderColor, params.plotBorderAlpha);
                _loc10.draw(params.use3DLighting);
                _loc3._alpha = data[_loc2].alpha;
                if (params.animation)
                {
                    if (Math.abs(data[_loc2].h) > config.shifts.yShift * 1.500000E+000)
                    {
                        _loc5 = 100;
                    }
                    else
                    {
                        _loc5 = null;
                    } // end else if
                    styleM.applyAnimation(_loc3, objects.DATAPLOT, macro, data[_loc2].x, 0, data[_loc2].y, 0, 100, 100, _loc5, null);
                } // end if
                styleM.applyFilters(_loc3, objects.DATAPLOT);
                if (params.showToolTip)
                {
                    _loc4 = mx.utils.Delegate.create(this, columnOnRollOver);
                    _loc4.index = _loc2;
                    _loc3.onRollOver = _loc4;
                    _loc3.onRollOut = _loc3.onReleaseOutside = mx.utils.Delegate.create(this, columnOnRollOut);
                    _loc3.onMouseMove = mx.utils.Delegate.create(this, columnOnMouseMove);
                } // end if
                if (data[_loc2].link != "" && data[_loc2].link != undefined && params.clickURL == "")
                {
                    _loc7 = mx.utils.Delegate.create(this, columnOnClick);
                    _loc7.index = _loc2;
                    _loc3.onRelease = _loc7;
                    continue;
                } // end if
                _loc3.useHandCursor = params.clickURL == "" ? (false) : (true);
            } // end if
        } // end of for
        clearInterval(config.intervals.plot);
    } // End of the function
    function drawValues()
    {
        var _loc4 = styleM.getTextStyle(objects.DATAVALUES);
        var _loc11 = _loc4.bold;
        var _loc13 = _loc4.italic;
        var _loc12 = _loc4.font;
        var _loc6 = 0;
        var _loc3;
        var _loc9 = dm.getDepth("DATAVALUES");
        var _loc2;
        var _loc5;
        var _loc8;
        var _loc10;
        var _loc7;
        for (var _loc2 = 1; _loc2 <= num; ++_loc2)
        {
            if (data[_loc2].isDefined && data[_loc2].showValue)
            {
                if (params.placeValuesInside)
                {
                    _loc7 = data[_loc2].h >= 0 ? ("bottom") : ("top");
                    _loc5 = data[_loc2].h >= 0 ? (data[_loc2].valTBY + params.valuePadding + config.shifts.yShift) : (data[_loc2].valTBY - params.valuePadding + config.shifts.yShift);
                }
                else
                {
                    _loc7 = data[_loc2].h >= 0 ? ("top") : ("bottom");
                    _loc5 = data[_loc2].h >= 0 ? (data[_loc2].valTBY - params.valuePadding) : (data[_loc2].valTBY + params.valuePadding + config.shifts.yShift);
                } // end else if
                if (params.placeValuesInside)
                {
                    _loc8 = data[_loc2].x;
                }
                else
                {
                    _loc8 = data[_loc2].value < 0 ? (data[_loc2].x) : (data[_loc2].x + config.shifts.xShift);
                } // end else if
                _loc10 = "center";
                _loc4.align = _loc10;
                _loc4.vAlign = _loc7;
                if (params.rotateValues)
                {
                    _loc4.bold = false;
                    _loc4.italic = false;
                    _loc4.font = _embeddedFont;
                    _loc6 = 270;
                }
                else
                {
                    _loc4.bold = _loc11;
                    _loc4.italic = _loc13;
                    _loc4.font = _loc12;
                    _loc6 = 0;
                } // end else if
                _loc3 = this.createText(false, data[_loc2].displayValue, cMC, _loc9, _loc8, _loc5, _loc6, _loc4, false, 0, 0);
                if (params.placeValuesInside && params.valuePadding + _loc3.height >= Math.abs(data[_loc2].h))
                {
                    if (!params.rotateValues)
                    {
                        if (data[_loc2].h >= 0)
                        {
                            _loc3.tf._y = data[_loc2].y - config.shifts.yShift - data[_loc2].h - _loc3.height - params.valuePadding;
                            _loc3.tf._x = _loc3.tf._x + config.shifts.xShift;
                        }
                        else
                        {
                            _loc3.tf._y = data[_loc2].y + Math.abs(data[_loc2].h) + params.valuePadding;
                        } // end else if
                    }
                    else if (data[_loc2].h >= 0)
                    {
                        _loc3.tf._y = data[_loc2].y - data[_loc2].h - params.valuePadding - config.shifts.yShift;
                        _loc3.tf._x = _loc3.tf._x + config.shifts.xShift / 2;
                    }
                    else
                    {
                        _loc3.tf._y = data[_loc2].y + Math.abs(data[_loc2].h) + _loc3.height + params.valuePadding;
                    } // end else if
                } // end else if
                if (!params.placeValuesInside && data[_loc2].h >= 0 && _loc5 - _loc3.height <= elements.canvasBg.y)
                {
                    if (!params.rotateValues)
                    {
                        _loc3.tf._y = _loc5 + 2 * params.valuePadding + config.shifts.yShift;
                        _loc3.tf._x = _loc3.tf._x - config.shifts.xShift;
                    }
                    else
                    {
                        _loc3.tf._y = _loc5 + 2 * params.valuePadding + _loc3.height + config.shifts.yShift;
                        _loc3.tf._x = _loc3.tf._x - config.shifts.xShift;
                    } // end if
                } // end else if
                if (!params.placeValuesInside && data[_loc2].h < 0 && _loc5 + _loc3.height >= elements.canvasBg.toY)
                {
                    if (!params.rotateValues)
                    {
                        _loc3.tf._y = _loc5 - 2 * params.valuePadding - _loc3.height;
                    }
                    else
                    {
                        _loc3.tf._y = _loc5 - 2 * params.valuePadding;
                    } // end if
                } // end else if
                styleM.applyFilters(_loc3.tf, objects.DATAVALUES);
                if (params.animation)
                {
                    styleM.applyAnimation(_loc3.tf, objects.DATAVALUES, macro, _loc3.tf._x, 0, _loc3.tf._y, 0, 100, null, null, null);
                } // end if
                ++_loc9;
            } // end if
        } // end of for
        clearInterval(config.intervals.dataValues);
    } // End of the function
    function setContextMenu()
    {
        var _loc3 = new ContextMenu();
        _loc3.hideBuiltInItems();
        var _loc4 = new ContextMenuItem("Print Chart", mx.utils.Delegate.create(this, printChart));
        _loc3.customItems.push(_loc4);
        if (params.showFCMenuItem)
        {
            _loc3.customItems.push(super.returnAbtMenuItem());
        } // end if
        cMC.menu = _loc3;
    } // End of the function
    function columnOnRollOver()
    {
        var _loc3 = arguments.caller.index;
        tTip.setText(data[_loc3].toolText);
        tTip.show();
    } // End of the function
    function columnOnRollOut()
    {
        tTip.hide();
    } // End of the function
    function columnOnMouseMove()
    {
        if (tTip.visible())
        {
            tTip.rePosition();
        } // end if
    } // End of the function
    function columnOnClick()
    {
        var _loc4 = arguments.caller.index;
        super.invokeLink(data[_loc4].link);
    } // End of the function
    function reInit()
    {
        super.reInit();
        num = 0;
        data = new Array();
        config.negativePresent = false;
    } // End of the function
} // End of Class
